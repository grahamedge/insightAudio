'''
Functions to download, convert, and save files from Youtube
as well as functions to parse the associated caption files
'''

import numpy as np
import youtube_dl
import pycaption
import ffmpy


def download_video(yt_id, save_folder = '/media/graham/OS/Linux Content/Youtube/Videos/'):
	'''Fetches the video file from https://www.youtube.com/watch?v=xxxxxxxxx
	where xxxxxxxxx is replaced by the input 'yt_id' 

	Downloaded file is saved as .mkv

	If Automatic captions are available, they are saved in the same location

	NOTES:
	- Some videos have automatic CC disabled (if the uploader doesn't appprove)
		and these should be detected so that they can be ignored
	- Sometimes the video download will fail, and we should detect the error and retry
	- This should really just short-cut directly to audio download, since we currently
		don't use the video
	'''

	#Download video file
	#-------------------
	save_format = save_folder+'%(id)s.%(ext)s'
	ydl_opts = {
	    'outtmpl': save_format,
	    'merge_output_format': 'mkv',
	    'writeautomaticsub': True
	    }
	ydl = youtube_dl.YoutubeDL(ydl_opts)

	with ydl:
	    link = 'https://www.youtube.com/watch?v='+yt_id
	    result = ydl.extract_info(
	        link,
	        download=True # We want the video
	    )

	if 'entries' in result:
	    # Can be a playlist or a list of videos
	    video = result['entries'][0]
	else:
	    # Just a video
	    video = result

	video_title = video['title']

	success = True #should detect download success

	return success, video_title

def download_video_metadata(yt_id):
	'''Just grab the metadata for the video, don't download the file'''

	#Download video file
	#-------------------
	ydl_opts = {}
	ydl = youtube_dl.YoutubeDL(ydl_opts)

	with ydl:
	    link = 'https://www.youtube.com/watch?v='+yt_id
	    result = ydl.extract_info(
	        link,
	        download=False # We just want to extract the info
	    )

	if 'entries' in result:
	    # Can be a playlist or a list of videos
	    video = result['entries'][0]
	else:
	    # Just a video
	    video = result

	video_title = video['title']

	#return important metadata
	return video_title	

def convert_to_wav(yt_id, vid_type = '.mkv', 
		video_loc = '/media/graham/OS/Linux Content/Youtube/Videos/',
		audio_loc = '/media/graham/OS/Linux Content/Youtube/Audio/'):
	'''Use ffmpeg to convert the audio in the downloaded .mkv file into .wav format'''

	#Extract audio and save to .wav file
	in_file = video_loc + yt_id + vid_type
	out_file = audio_loc + yt_id + '.wav'
	ff = ffmpy.FFmpeg(
	    inputs={in_file: None},
	    outputs={out_file: None}
	    )
	ff.run()

	success = True

	return success

def timestamp_to_seconds(timestamp):
	'''Take a .vtt timestamp of the form hh:mm:ss.xxx with xxx being milliseconds
	and returns an integer for the number of seconds since the start of the video'''
	elements = timestamp.split(':')

	h = int(elements[0])
	m = int(elements[1])
	s = float(elements[2]) 	#seconds are given in decimal notation to the nearest msec

	seconds =  h*3600 + m*60 + s
	return seconds

def read_vtt_captions(yt_id, 
		caption_loc = '/media/graham/OS/Linux Content/Youtube/Videos/'):
	'''Open the .vtt caption file with the automatic captions generated by Youtube
	and generate a text transcript, and words-per-second data for the video'''

	filename = caption_loc + yt_id + '.en.vtt'

	try:
		captions = codecs.open(filename, 'r').read()
	except:
		captions = open(filename,'r').read()
		captions = unicode(captions, errors='replace')

	vttReader = pycaption.WebVTTReader()
	lang = 'en-US'

	if vttReader.detect(captions):
		C = vttReader.read(captions,lang)

	try:
		caps = C.get_captions(lang)
	except:
		print('Error extracting english captions!')

	text_list = [cap.get_text() for cap in caps]
	time_stamp_list = [timestamp_to_seconds(cap.format_start()) for cap in caps]

	return text_list, time_stamp_list

def calc_wps(text, seconds):
	'''Given two lists 'text' and 'seconds' representing the closed captions
	for a video file, returns a new list of the estimated word-per-second spoken
	'''
	
	#calculate the lengths of time
	start = np.asarray(seconds)
	end = np.roll(start,-1)

	dt = end-start 	# approx amount of time taken to speak each caption
	dt[-1] = dt[-2]	# we cannot properly calculate dt for the last timestamp
					#	so use an approximate value

	#calculate the number of words
	n_words = [len(line.split(' ')) for line in text]
	n = np.asarray(n_words)

	wps = n/dt
	return wps

def calc_length(seconds):
	'''given a list of timestamps 'seconds'
	calculates the approximate length of each associated phrase in the captions
	based on the distance to the next timestamp''' 
	t = np.asarray(seconds)
	dt = np.roll(t,-1) - t
	dt[-1] = dt[-2] #ugly fix for the poorly defined final value
	return dt

def shift_timestamps(seconds, lengths):
	'''timestamps for captioning are given at the start of the line
	this shifts them to the approximate midpoint of the spoken like to
	match up better with the audio metrics in plots and analysis'''
	t = np.asarray(seconds)
	dt = np.asarray(lengths)
	t = t+dt/2
	return t